# [Задача "Понимание JVM"](https://github.com/Razum4e/jd-homeworks/blob/master/jvm/task1/README.md)

```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

### ClassLoader

На начальном этапе выполнения программы внутри JVM видит (из примера) классы:
- JvmComprehension;
- String;
- Object;
- Integer;
- System;
- PrintStream; (System.out.`println`)

затем отправляет запрос в ClassLoader на загрузку этого класса.

Непосредственно в ClassLoader'e имеется 3 ClassLoader'a:

`ClassLoader's`:

`Application ClassLoader`->`Platform ClassLoader`->`Bootstrap ClassLoader`

В Bootstrap будут загружены базовые классы Java (String, Object, Integer,System,PrintStream), а в Application будет загружен класс пользовательского уровня (JvmComprehension). В случае, если во время выполнения программы не будет найден класс, то выдаст Runtime исключение `java.lang.ClassNotFoundException`

Далее идет связывание Linking
`Verify`->`Prepare`->`Resolve`
После прохождения данных этапов подсистемы подзагрузчика классов происходит крайний этап `Initialization` инициализация. Здесь происходит выполнение static инициализаторы и инициализаторы static полей:
- static void main()
- static void printAll()

Вся эта информация сохранялась в область памяти Metaspace, где хранится информация о данных классов и константах.

### Runtime Data Area

В JVM имеются области памяти:
- `Stack Memory (стек)` - хранение инф-ции о фреймах вызова функций
- `Heap (куча)` - хранение ссылочной информации
- `Metaspace` - хранит мета информацию о классах

После выполнения ClassLoader'a 

Программа знает что есть такой класс `public class JvmComprehension {`, где есть точка входа `public static void main(String[] args) {`. В момент вызова метода создается фрейм(кадр) в `Stack`.Во фрейме хранится вся информация области видимости метода.

Далее по порядку:

1. `int i = 1;` - создается пременная , где она добавляется в `stack` во фрейм `main`.
2. `Object o = new Object();` - так как создается объект `Object` с использованием оператора `new`, зарезервируется память в `Heap` и там же создается, переменная является ссылочным типом, соответственно название `o` сохраняется в виде ссылки в `Stack`. `o` -> `Object`
3. `Integer ii = 2;` - создание `Integer` в куче и ссылка на фрейм мейна в стеке `ii = 2`
4. `printAll(o, i, ii);` - вызов метода. Создание нового фрейма `printAll()` в стеке с переменными:
	- `o` с ссылкой на Object в куче
	- `int i = 1;`
	- `ii` c ссылкой на Integer в куче
5. `Integer uselessVar = 700;` - аналогично №3. Создается переменная `uselessVar = 700` с ссылкой на НОВЫЙ Integer в куче.
6. `System.out.println(o.toString() + i + ii);` - создание еще одного фрейма в стеке с параметром `x`.
7. `System.out.println("finished");` - создание нового фрейма в стеке.

### Execution Engine, Garbage Collection

![Схема ссылок java](//https://www.freecodecamp.org/news/content/images/size/w600/2021/01/image-76.png)

Во время выполнения программы код выполняется строка за строкой, а так же параллельно возможны операции, когда методы компилируются в машинный код прямо во время выполнения программы. JVM использует интерпретатор, где байт- код в `.class` файле интерпретирует строка за строкой, затем его выполняет. Для повышения эффективности интерпретатора используется Just In Time (JIT) компилятор. Он проверяет как часто вызывается какой - либо метод, и если слишком часто - то компилирует его код и сохраняет в кэш, а при последствующих вызовах метода он выполняет уже готовый машинный код, из кэша, что происходит значительно быстрее.

По ходу выполнения программы, используется встроенный уборщик мусора для освобождения памяти (для сборки мусора происходит полная остановка программы(для безопасности)). Сборщик использует два основных метода для сбора:
- подсчет ссылок (меньше)
- обход графа достижимых объектов (чаще) - пример на схеме выше

Непостижимые объекты удаляются, а достижимые группируются по времени жизни - чем дольше объект живет, тем реже проверяют, нужно ли его удалить.
